1、进程、线程：
    进程，是系统进行资源分配和调度的独立单位；
    线程，是进程中独立运行的子任务。

2、为什么使用多线程？
    使用多线程，可以通过使用异步的方式，最大限度的理用CPU的空闲时间来处理其他的任务。
    由于CPU在这些任务之间，通过不断的切换时间切片，使得在同一时间内运行不同种类的任务。

3、使用多线程的方式：
    1）集成Thread
    2）实现Runnable
    3）Callable和Future实现带返回值的线程
    4）采用线程池

4、线程之间数据共享：
    1）通过对new共同的一个Thread或Runnable接口，处理。
    2）设置需要共享的变量为全局变量。
    3）生成外部共享变量对象，逐一传递到各个线程中。

5、理解Thread.currentThread().getName() 和 this.getName()的区别：
    前者指当前代码段，正在被哪个线程执行
    后者指当前代码属于哪个线程

6、isAlive：
    判断线程是否处于活动状态（线程已经启动且尚未终止）

7、停止线程：
    1）使用出标志，使得退线程正常退出
    2）使用stop方法，强制退出
    3）使用interrupt方法中断线程
    4）抛异常进行终端

8、isInterrupt() 和 interrupted() 方法的区别：
    都是测试当前线程是否已经中断。后者会清除中断状态，而前者不会。

9、suspend和resume：
    暂停线程和重新启动线程。

10、yield()：
    放弃当前的CPU资源，让给其他的任务。但放弃时间不确定，有可能刚放弃，就又重新获得。

11、优先级priority：
    设置范围：
    MIN_PRIORITY = 1;
    NORM_PRIORITY = 5;
    MAX_PRIORITY = 10;

    线程优先级有继承性：A线程启动B线程，再不设置线程级别的情况下，B线程的优先级与A保持一致。
    线程优先级有规则性：高优先级的线程，大部分情况下，比优先级低的线程先执行完成。
    线程优先级有随机性：高优先级的线程，不一定比低优先级的线程先执行完成。

12、守护线程和普通线程：
    守护线程是一种特殊的线程，当进程种不存在非守护线程时，守护线程则自动销毁。典型的守护线程是垃圾回收线程。
    普通的线程可以通过setDaemon(true)来设置为守护线程。


13、线程间通讯，可以通过共同的内部变量：
    a、不断的while循环去获得信息，会导致资源浪费。（不推荐）
    b、通过等待唤醒机制
        wait方法之前需要获得对象级别的锁，固只能在同步方法或同步块中执行。
        执行wait方法后，释放锁。
        同理，notify()也需要在同步方法或同步代码块中执行。用来通知那些可能等该对象锁的其他线程。
        如果有多个线程等待，则随机挑选出一个在wait状态的线程。

    需要注意的是：执行notify后，并不会立马释放锁，wait对象的线程也不能立马获得锁。
    需要等待notify方法的线程执行完，也就是退出synchronized代码块后，当前线程才能释放锁。

总结：wait使线程停止运行，而notify使停止的线程继续运行。

14、公平锁和非公平锁：
    锁Lock分为公平锁和非公平锁。
    公平锁表示线程获得锁的顺序是按照线程加锁的顺序来分配的，先来显出FIFO。
    非公平锁就是获取锁是抢占机制，随机获得锁。

    Lock的实现原理：
    构成：首先是通过维护一个volatile标识的状态字段，和一个syc继承了AQS同步队列的类来实现的。
    1）当一个线程lock时，首先判断当前状态是否为0，0的话，说明没有线程占锁。通过CAS的方式设置状态为1，多个线程的同时设置的情况下，也只有一个线程能够设置成功。
    2）设置状态成功了，判断该节点是否在队列中，如果存在则移除。如果不在队列中，也无需进队列，直接进行临界区的访问。
    3）设置状态失败，则需要把自己加入到队列中并且阻塞。
    4）当前线程释放锁，会将当前的状态设置为0，并唤醒队列中的首节点。然后唤醒的首节点再去竞争锁，重复获取锁的过程。队列中的节点，需要前一个节点对后面的节点进行唤醒。

    公平锁和非公平锁的主要区别，在于获得锁的过程，非公平锁不管队列中的情况，就去插队竞争锁。而公平锁，除了判断当前状态以外，还需要判断当前节点是否为首节点。

15、condition完成等待/通知：
    相比于synchronized和wait/notify，lock与condition能实现多路选择性的通知，更加灵活。

16、锁的状态一共有四种：无锁状态、偏向锁、轻量级锁、重量级锁
    锁的状态会随着竞争情况逐步升级，升级后不能降级。
    a、偏向锁：
        优点：加锁和解锁不需要额外的消耗，执行非常快
        缺点：如果线程之间存在竞争，会带来额外的锁撤销的消耗
        场景：适用于一个线程访问同步块的场景
    b、轻量级锁：
        优点：竞争的线程不会堵塞，使用自旋cas来获得锁
        缺点：如果始终无法获得锁的话，自旋cas会消耗cpu的资源
        场景：追求响应时间，同步块执行非常快
    c、重量级锁：
        优点：线程不适应自旋，不会消耗cpu资源
        缺点：线程堵塞，响应时间变长
        场景：追求吞吐量，同步块执行缓慢

17、java如何实现原子性；
    a、使用自旋CAS实现原子操作（compareAndSet）
        问题：1）ABA问题：检查值是否变化时，有可能是从A变成B又变成了A。解决方案：增加版本号+可以通过AtomicReference类实现
              2）循环时间长：如果长时间不成功，则会对CPU有较大的消耗。
              3）只能保证一个共享变量的原子性操作。
    b、使用锁机制，实现原子性操作

18、涉及到了CAS原理：
    CAS的操作，简单来说是一种乐观锁的方式，通过比较并更新的方式来更新值。
    认为该位置的值是A，如果是A，则更新为B；如果不是A，则返回该位置当前值。

    缺点：
    1、ABA问题：
        简单来说，就是线程1取得内存值，线程2也取得了内存值，线程2修改该值为B，然后线程2又将该值变成A。
        这样对线程1来说，也是满足预期值，会对值进行变更。
        可以通过AtomicStampedReference来解决ABA的问题，增加标记的方式。
    2、自旋CAS长期不成功的话，会给CPU带来比较大的资源浪费。
    3、只能保证一个共享变量的原子操作。


19、内存屏障：
    LoadLoad：
        Load1->LoadLoad->Load2:确保Load1数据的装载，先于Load2及所有的后续装载
    LoadStore：
        Load1->LoadStore->Store1:确保Load1数据的装载，先于Store1及后续的所有存储指令
    StoreStore：
        Store1->StoreStore->Store2:确保Store1数据的存储，先于Store2及后续的所有存储指令
    StoreLoad：
        是一个全能屏障，有上面三个屏障的功效

20、volatile特性：
    可见性：对一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入。
    有序性：通过禁止编译指令重排，保证指令执行于代码逻辑相同

21、防止编译指令重排是通过插入内存屏障来实现的：
    volatile写操作：前加 StoreStore屏障，后加StoreLoad屏障
    volatile读操作：后加LoadLoad屏障，后加LoadStore屏障

22、happens-before：
    定义：在JMM中，如果一个操作的结果，需要对另一个操作可见，那么这两个操作之间是happens-before关系。
    规则：
        a、一个操作happens-before另外一个操作，那么第一个操作的结果对第二个操作可见，且第一个操作的执行顺序排在第二个操作之前。
        b、如果两个操作符合happens-before关系，并不意味着一定要按照该顺序执行。
           如果重排序之后的结果与happens-before关系执行的结果一致，JMM允许这种重排序。

    as-if-serial：
    定义：不管怎么重排序，单线程的执行结果不能被改变。

    happens-before与as-if-serial：
    as-if-serial语义保证单线程内的执行结果不变，happends-before保证正确同步的多线程执行结果不被改变。

23、AQS（AbstractQueuedSynchronizer）队列同步器：
    使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获得线程的排队工作。
    同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取
同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其
加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再
次尝试获取同步状态。



24、Fork/Join框架：
    继承类分为：RecursiveAction（没有返回结果的任务）
                RecursiveTask（用于有返回结果的任务）
    需要通过ForkJoinPool来执行
    工作窃取模式，使得所有的线程都能有任务可以干，充分利用cpu资源。但是在任务较少的情况下，执行速度，并不一定比单线程处理要快。


25、juc包下，Atomic包，提供了原子操作类：
    1）原子更新基本类型：AtomicBoolean、AtomicInteger、AtomicLong
    2）原子更新数据：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
    3）原子更新引用类型：AtomicReference、AtomicReferenceFieldUpdater、AtomicMarkableReference
    4）原子更新字段类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference

26、CountDownLatch：允许一个或多个线程等待其他线程完成操作。
    简单来说，就是设置一个数量，当数量减到0时，await后的方法能够执行。

    CyclicBarrier：设置屏障，线程到屏障后，等待。
    当屏障数到达约定的数量时，所有的等待后的方法，可以同时执行。

    CyclicBarrier相比CountDownLatch方法来说，还提供了reset()方法，可以重置。
    还提供了isBroken方法，判断堵塞的线程是否被中断。更加灵活一点。

    Semaphore（信号量）用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。

    Exchanger（交换者）是一个用于线程间协作的工具类


27、线程池的好处：
    1）降低资源消耗：通过重复利用已经创建的线程，降低线程创建和销毁造成的消耗。
    2）提高响应速度：当任务达到时，任务可以不用等到线程创建就能立马执行。
    3）提高线程的管理：线程是稀缺资源，如果无限创建，不仅消耗资源，还会降低系统的稳定性，可以通过线程池，统一分配、调优和监控。

28、线程池，并不提倡通过ThreadPoolExecutor来创建，一般通过Executors类，来创建线程池。

    Executor框架，由三部分组成：
    1）任务
    2）任务的执行
    3）异步的计算结果

    主要成员：
    1）ThreadPoolExecutor：通过工厂Executors来创建。可以创建三种类型，SingleThreadExecutor、FixedThreadExecutor和CachedThreadPool。
        a、FixedThreadExecutor：使用固定线程数。适用于为了满足资源管理的需求，而需要限制当前线程数量的场景。
        b、SingleThreadExecutor：使用单个线程。适用于保证顺序的执行各个任务，并且在任意的时间点，不会有多个线程活动的应用场景。
        c、CachedThreadPool：根据需要，创建新的线程。是大小无界的线程池。适用于执行很多的短期任务的小程序，或者是负载较轻的服务器。
    2）ScheduledThreadPoolExecutor：适用于多个后台线程执行周期任务，同时为了满足资源管理的需求需要限制后台线程的数量的应用场景。
       SingleThreadScheduledExecutor：适用于单个后台线程执行周期任务，同时保证顺序执行。
    3）Future接口和FutureTask类，来表示异步计算的结果。
    4）Runnable接口和Callable接口的实现类。区别在于Runnable不会返回结果，Callable可以返回结果。