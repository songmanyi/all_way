1、JVM运行时数据区：程序计数器、虚拟机栈、本地方法栈、方法区、Heap堆
【程序计数器】
指向当前线程正在执行的字节码指令的地址 行号
每个线程有一个程序计数器，当cpu通过上下文切换到某个线程时，通过程序计数器，判断程序继续执行的步骤。

【虚拟机栈】
存储当前线程运行方法所需要的数据、指令、返回地址->包含局部变量表※、操作数栈※、动态链接、出口
虚拟机栈，是线程隔离的，即每个线程都有自己独立的虚拟机栈。

【本地方法栈】
本地方法入栈出栈的一个过程，功能上与虚拟机栈类似，但服务的对象是JVM中执行的native方法
带native标识的方法

【方法区】
存储的是类信息、常量、静态变量、JIT（即时编译器编译后的代码）

【Heap堆】
涉及到了内存模式：JMM
1.8之前：新生代（eden生成区、s0幸存区FromSpace、s1幸存区ToSpace：8-1-1）、老年代、永久代
1.8及之后：新生代（eden生成区、s0幸存区FromSpace、s1幸存区ToSpace：8-1-1）、老年代、Meta Space（元空间）

元空间与永久带类似，都是方法区的实现，不过元空间不在JVM中，而是使用本地内存。

为什么新生代的内存比例是8:1:1？
1、对象的生命周期不一样，所以要分代
2、新生代的对象，大部分理解为朝生兮死会被回收掉，所以只通过s1存储，就足够。利用率能到90%。
3、分配担保概念，就是s1如果u不够用了，怎么办？可以放到老年代中。

空间分配的大体规律：
根据GC日志获得老年代中活跃数据的大小，例如300M，那么各分区大小可以分为：
总堆：300 * 4 = 1200M
新生代：300 * （1或1.5） = x
老年代：1200 - x

什么样的对象需要被GC？
判断算法：
  -引用计数法
  -可达性分析
