如何判断对象是垃圾对象？
    1、引用计数法：
        不能避免相互引用的问题
    2、可达性分析：
        可避免相互引用的问题。通过与GCRoot是否能够链路可达，判断是否为垃圾对象。
        其中可以成为GCRoot的有：
            虚拟机栈的局部变量表所引用的对象
            方法区的类属性所引用的对象
            方法区的常量所引用的对象
            本地方法栈所引用的对象

垃圾回收对象算法：
    1、标记清除
        主要分为两部分：
            a、标记：从根集合开始扫描，对存活的对象进行标记
            b、清除：扫描整个空间，回收未标记的对象
        优点：比较简单，不需要额外空间
        缺点：两次扫描，耗时严重；会产生内存碎片
    2、复制算法（新生代的垃圾回收）
        从根集合开始，找到From中存活对象后，拷贝到To内存中。然后两块内存交换身份
        优点：没有两次扫描的过程，效率高；没有内存碎片，通过free-pointer实现快速的内存分配
        缺点：需要双倍的空间，浪费空间
    3、标记整理
        主要分为两部分：
            a、标记：与标记清除算法一样
            b、压缩：再次扫描，并往一端滑动内存对象。
        优点：没有内存碎片，也是通过free-pointer实现的
        缺点：需要移动对象，非常耗时

内存分配策略：
    1、优先分配Eden区
    2、大对象直接分配到老年代
    3、长期存活的对象，进入老年代（年龄15）
    4、空间分配担保：
        每次minorGC之前，会判断一下，老年代中连续可用的空间，是否大于新生代所有对象的总和空间。
        如果不大于，则会判断是否允许担保失败，允许的话，则判断老年代中最大可用空间，是否大于历次晋升到老年代对象的平均大小。
        如果大于，则尝试进行一次minorGC，如果小于，则放弃minorGC，改为fullGC
    5、动态年龄对象：
        如果存活空间中，相同年龄的对象大小总和大于存活空间的一半，则年龄大于等于该年龄的对象，直接进入老年代

逃逸分析和栈上分配：
    逃逸分析：方法内部创建的对象，再方法外部被使用
    栈上分配：没有逃逸的对象，再栈上进行分配