内存屏障：
    LoadLoad：
        Load1->LoadLoad->Load2:确保Load1数据的装载，先于Load2及所有的后续装载
    LoadStore：
        Load1->LoadStore->Store1:确保Load1数据的装载，先于Store1及后续的所有存储指令
    StoreStore：
        Store1->StoreStore->Store2:确保Store1数据的存储，先于Store2及后续的所有存储指令
    StoreLoad：
        是一个全能屏障，有上面三个屏障的功效

volatile特性：
    可见性：对一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入。
    有序性：通过禁止编译指令重排，保证指令执行于代码逻辑相同

防止编译指令重排是通过插入内存屏障来实现的：
    volatile写操作：前加 StoreStore屏障，后加StoreLoad屏障
    volatile读操作：后加LoadLoad屏障，后加LoadStore屏障

happens-before：
    定义：在JMM中，如果一个操作的结果，需要对另一个操作可见，那么这两个操作之间是happens-before关系。
    规则：
        a、一个操作happens-before另外一个操作，那么第一个操作的结果对第二个操作可见，且第一个操作的执行顺序排在第二个操作之前。
        b、如果两个操作符合happens-before关系，并不意味着一定要按照该顺序执行。
           如果重排序之后的结果与happens-before关系执行的结果一致，JMM允许这种重排序。

as-if-serial：
    定义：不管怎么重排序，单线程的执行结果不能被改变。

happens-before与as-if-serial：
    as-if-serial语义保证单线程内的执行结果不变，happends-before保证正确同步的多线程执行结果不被改变。

※※AQS（AbstractQueuedSynchronizer）队列同步器：
使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获得线程的排队工作。

Fork/Join框架：
继承类分为：RecursiveAction（没有返回结果的任务）
            RecursiveTask（用于有返回结果的任务）
需要通过ForkJoinPool来执行
工作窃取模式，使得所有的线程都能有任务可以干，充分利用cpu资源。但是在任务较少的情况下，执行速度，并不一定比单线程处理要快。


juc包下，Atomic包，提供了原子操作类：
1、原子更新基本类型：AtomicBoolean、AtomicInteger、AtomicLong
2、原子更新数据：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
3、原子更新引用类型：AtomicReference、AtomicReferenceFieldUpdater、AtomicMarkableReference
4、原子更新字段类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference


涉及到了CAS原理：
CAS的操作，简单来说是一种乐观锁的方式，通过比较并更新的方式来更新值。
认为该位置的值是A，如果是A，则更新为B；如果不是A，则返回该位置当前值。

缺点：
1、ABA问题：
简单来说，就是线程1取得内存值，线程2也取得了内存值，线程2修改该值为B，然后线程2又将该值变成A。
这样对线程1来说，也是满足预期值，会对值进行变更。
可以通过AtomicStampedReference来解决ABA的问题，增加标记的方式。
2、自旋CAS长期不成功的话，会给CPU带来比较大的资源浪费。
3、只能保证一个共享变量的原子操作。


CountDownLatch：允许一个或多个线程等待其他线程完成操作。
    简单来说，就是设置一个数量，当数量减到0时，await后的方法能够执行。

CyclicBarrier：设置屏障，线程到屏障后，等待。
    当屏障数到达约定的数量时，所有的等待后的方法，可以同时执行。

CyclicBarrier相比CountDownLatch方法来说，还提供了reset()方法，可以重置。
还提供了isBroken方法，判断堵塞的线程是否被中断。更加灵活一点。


Semaphore（信号量）用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。


Exchanger（交换者）是一个用于线程间协作的工具类


线程池的好处：
1）降低资源消耗：通过重复利用已经创建的线程，降低线程创建和销毁造成的消耗。
2）提高响应速度：当任务达到时，任务可以不用等到线程创建就能立马执行。
3）提高线程的管理：线程是稀缺资源，如果无限创建，不仅消耗资源，还会降低系统的稳定性，可以通过线程池，统一分配、调优和监控。

线程池，并不提倡通过ThreadPoolExecutor来创建，一般通过Executors类，来创建线程池。

Executor框架，由三部分组成：
1）任务
2）任务的执行
3）异步的计算结果

主要成员：
1）ThreadPoolExecutor：通过工厂Executors来创建。可以创建三种类型，SingleThreadExecutor、FixedThreadExecutor和CachedThreadPool。
    a、FixedThreadExecutor：使用固定线程数。适用于为了满足资源管理的需求，而需要限制当前线程数量的场景。
    b、SingleThreadExecutor：使用单个线程。适用于保证顺序的执行各个任务，并且在任意的时间点，不会有多个线程活动的应用场景。
    c、CachedThreadPool：根据需要，创建新的线程。是大小无界的线程池。适用于执行很多的短期任务的小程序，或者是负载较轻的服务器。
2）ScheduledThreadPoolExecutor：适用于多个后台线程执行周期任务，同时为了满足资源管理的需求需要限制后台线程的数量的应用场景。
   SingleThreadScheduledExecutor：适用于单个后台线程执行周期任务，同时保证顺序执行。
3）Future接口和FutureTask类，来表示异步计算的结果。
4）Runnable接口和Callable接口的实现类。区别在于Runnable不会返回结果，Callable可以返回结果。
