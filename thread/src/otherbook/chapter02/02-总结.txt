内存屏障：
    LoadLoad：
        Load1->LoadLoad->Load2:确保Load1数据的装载，先于Load2及所有的后续装载
    LoadStore：
        Load1->LoadStore->Store1:确保Load1数据的装载，先于Store1及后续的所有存储指令
    StoreStore：
        Store1->StoreStore->Store2:确保Store1数据的存储，先于Store2及后续的所有存储指令
    StoreLoad：
        是一个全能屏障，有上面三个屏障的功效

volatile特性：
    可见性：对一个volatile变量的读，总能看到（任意线程）对这个volatile变量最后的写入。
    有序性：通过禁止编译指令重排，保证指令执行于代码逻辑相同

防止编译指令重排是通过插入内存屏障来实现的：
    volatile写操作：前加 StoreStore屏障，后加StoreLoad屏障
    volatile读操作：后加LoadLoad屏障，后加LoadStore屏障

happens-before：
    定义：在JMM中，如果一个操作的结果，需要对另一个操作可见，那么这两个操作之间是happens-before关系。
    规则：
        a、一个操作happens-before另外一个操作，那么第一个操作的结果对第二个操作可见，且第一个操作的执行顺序排在第二个操作之前。
        b、如果两个操作符合happens-before关系，并不意味着一定要按照该顺序执行。
           如果重排序之后的结果与happens-before关系执行的结果一致，JMM允许这种重排序。

as-if-serial：
    定义：不管怎么重排序，单线程的执行结果不能被改变。

happens-before与as-if-serial：
    as-if-serial语义保证单线程内的执行结果不变，happends-before保证正确同步的多线程执行结果不被改变。

※※AQS（AbstractQueuedSynchronizer）队列同步器：
使用一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获得线程的排队工作。

Fork/Join框架：
继承类分为：RecursiveAction（没有返回结果的任务）
            RecursiveTask（用于有返回结果的任务）
需要通过ForkJoinPool来执行
工作窃取模式，使得所有的线程都能有任务可以干，充分利用cpu资源。但是在任务较少的情况下，执行速度，并不一定比单线程处理要快。


juc包下，Atomic包，提供了原子操作类：
1、原子更新基本类型：AtomicBoolean、AtomicInteger、AtomicLong
2、原子更新数据：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray
3、原子更新引用类型：AtomicReference、AtomicReferenceFieldUpdater、AtomicMarkableReference
4、原子更新字段类：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicStampedReference


涉及到了CAS原理：
CAS的操作，简单来说是一种乐观锁的方式，通过比较并更新的方式来更新值。
认为该位置的值是A，如果是A，则更新为B；如果不是A，则返回该位置当前值。

缺点：
1、ABA问题：
简单来说，就是线程1取得内存值，线程2也取得了内存值，线程2修改该值为B，然后线程2又将该值变成A。
这样对线程1来说，也是满足预期值，会对值进行变更。
可以通过AtomicStampedReference来解决ABA的问题，增加标记的方式。
2、自旋CAS长期不成功的话，会给CPU带来比较大的资源浪费。
3、只能保证一个共享变量的原子操作。


CountDownLatch：允许一个或多个线程等待其他线程完成操作。
    简单来说，就是设置一个数量，当数量减到0时，await后的方法能够执行。

CyclicBarrier：设置屏障，线程到屏障后，等待。
    当屏障数到达约定的数量时，所有的等待后的方法，可以同时执行。

CyclicBarrier相比CountDownLatch方法来说，还提供了reset()方法，可以重置。
还提供了isBroken方法，判断堵塞的线程是否被中断。更加灵活一点。


Semaphore（信号量）用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。


Exchanger（交换者）是一个用于线程间协作的工具类