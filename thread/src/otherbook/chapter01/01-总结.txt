1、上下文切换：
多线程的执行，可以通过CPU给线程分配时间片，来实现这个机制，由于切换的比较快，
并且时间片比较短，所以感觉像是再一起执行。

通过时间片分配算法，来实现多线程的情况下，当从一个任务切换到下一个任务之间，
会保存一个任务的状态，以便下次切换回来后，可以加载这个任务的状态。

从保存到再次加载的过程，就是上下文切换。

2、多线程一定快吗？
答案是不一定的。因为再多线程之间，需要不断的进行上下文切换，也是需要浪费资源的。

3、避免上下文切换浪费资源的方式：
a、无锁并发编程：不加锁进行并发操作。譬如把数据按照hashcode进行分段，不同的线程处理不同的数据。
b、CAS算法：简单来说就是通过不断的循环区修改目标，知道修改完成则退出循环。不需要加锁。
c、使用最少线程：避免创建不必要的线程。譬如较少的数据，通过创建很多个线程来实现。
d、协程：一个线程中，执行多个任务的操作和切换。
    目前了解到可以在java程序中应用的协程组件有以下几种：
    javaflow：http://commons.apache.org/sandbox/commons-javaflow/
    Coroutines：https://github.com/offbynull/coroutines
    Kilim：https://github.com/kilim/kilim

4、避免死锁的常见方法：
    a、避免一个线程同时获得多个锁
    b、尝试使用定时锁。lock.tryLock(long)

5、锁的状态一共有四种：无锁状态、偏向锁、轻量级锁、重量级锁
    锁的状态会随着竞争情况逐步升级，升级后不能降级。
    a、偏向锁：
        优点：加锁和解锁不需要额外的消耗，执行非常快
        缺点：如果线程之间存在竞争，会带来额外的锁撤销的消耗
        场景：适用于一个线程访问同步块的场景
    b、轻量级锁：
        优点：竞争的线程不会堵塞，使用自旋cas来获得锁
        缺点：如果始终无法获得锁的话，自旋cas会消耗cpu的资源
        场景：追求响应时间，同步块执行非常快
    c、重量级锁：
        优点：线程不适应自旋，不会消耗cpu资源
        缺点：线程堵塞，响应时间变长
        场景：追求吞吐量，同步块执行缓慢

6、java如何实现原子性；
    a、使用自旋CAS实现原子操作（compareAndSet）
        问题：1）ABA问题：检查值是否变化时，有可能是从A变成B又变成了A。解决方案：增加版本号
              2）循环时间长：如果长时间不成功，则会对CPU有较大的消耗。
              3）只能保证一个共享变量的原子性操作。可以通过AtomicReference类实现
    b、使用锁机制，实现原子性操作