1、线程间通讯，可以通过共同的内部变量：
a、不断的while循环去获得信息，会导致资源浪费。（不推荐）
b、通过等待唤醒机制
wait方法之前需要获得对象级别的锁，固只能在同步方法或同步块中执行。
执行wait方法后，释放锁。
同理，notify()也需要在同步方法或同步代码块中执行。用来通知那些可能等该对象锁的其他线程。
如果有多个线程等待，则随机挑选出一个在wait状态的线程。

需要注意的是：执行notify后，并不会立马释放锁，wait对象的线程也不能立马获得锁。
需要等待notify方法的线程执行完，也就是退出synchronized代码块后，当前线程才能释放锁。

总结：wait使线程停止运行，而notify使停止的线程继续运行。

总结一句话：

2、notifyAll()唤醒所有wait状态的线程


3、生产者/消费者
一生产者，一消费者
一生产，多消费，通过栈

4、两个线程依次打印A、B


5、通信方式，还可以通过管道流的方式。


6、join()/join(long):
作用是等待线程对象销毁。

join(long) 与 sleep(long)的区别：
join(long)内部实现是wait()，有释放锁的功能。
sleep(long)不释放锁

7、ThreadLocal解决每个线程绑定自己的值。
