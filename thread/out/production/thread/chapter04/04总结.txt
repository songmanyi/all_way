1、重入锁：ReentrantLock的使用

2、condition完成等待/通知：
相比于synchronized和wait/notify，lock与condition能实现多路选择性的通知，更加灵活。

wait 相当于condition.awati();
wait(long) 相当于 condition.await(long, TimeUnit)
notify 相当于 condition.signal();
notifyAll 相当于 condition.signalAll();

3、通过condition完成部分唤醒

4、2个线程交替打印

5、2组线程交替打印

6、公平锁和非公平锁：
锁Lock分为公平锁和非公平锁。
公平锁表示线程获得锁的顺序是按照线程加锁的顺序来分配的，先来显出FIFO。
非公平锁就是获取锁是抢占机制，随机获得锁。

lock和synchronized的区别：
1）lock是个接口，有具体的实现类，来完成加锁；synchronized是jvm提供的关键字。
2）lock分为公平锁和非公平锁，synchronized是非公平锁
3）lock加锁和解锁，通过具体方法来实现，更加的灵活。包括通过Condition进行通知，可以支持多路和指定等待通知。
   synchronized释放锁的实际是执行完成或异常等，不是显示的。

   lock可以通过方法判断是否获得锁，而synchronized不可以。
4）Lock适合大量同步的代码的同步问题。synchronized适合代码少量的同步问题。
   原因是，synchronized中，锁是不断升级的，从自旋锁到轻量级到重量级锁，等待会越来越严重。
           所以当大量同步处理，不太适合synchronized。

7、方法描述：
getHoldCount()->查询当前线程保持此锁定的个数，调用lock的次数
getQueneLenth()->返回正等待获取此锁定的线程估计数
getWaitQueneLenth()->返回正等待condition条件的估计数