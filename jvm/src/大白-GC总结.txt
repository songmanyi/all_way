命令：
    jps-> 查找所有java线程
    jinfo -flags 端口号->查看jvm的配置信息（运行时参数）
    jamp -heap 端口号->查看内存信息

JVM体系结构，主要分为三大部分：
    1、类加载器
    2、运行时数据区，细分为程序计数器、虚拟机栈、本地方法栈、方法区、堆
    3、执行引擎

类加载器ClassLoader分为三种：
    1、Bootstrap Class Loader
    2、Extension Class Loader
    3、System Class Loader

    双亲委派机制：先从父加载器找是否已经加载了，没有加载的话，在加载Class
    沙箱机制，就是jdk的代码不被串改，保证安全。

    反射三种方式：
    Class c = Foo.class;
    Class c = foo.getClass()
    Class c = Class.forName("类的相对路径");

程序计数器：
    每个线程都有一个程序计数器，是线程私有的，指向方法区中的方法字节码，当CPU进行上下文切换时，切换到该线程后，继续往下执行。

虚拟机栈：
    每个线程都有一个虚拟机栈，也是线程私有的。
    存储的栈元素是栈帧，每调用一个方法，就会生成一个栈帧，用来存储局部变量表（入参、出参、方法内部变量）、操作数栈（记录出栈、入栈的操作）、动态链接、方法出口等信息。
    虚拟机栈，是一个先入后出的栈。

本地方法栈：
    本地方法栈与虚拟机栈类似，但是服务的对象是JVM中native标识的方法

方法区：
    方法区主要存储的是类信息、常量、静态变量，是线程共享的。
    jdk1.8之前，有永久代来专门存储方法区。1.8以后，通过元空间存储。

堆(heap)：
    一个jvm实例只有一个堆内存，内存大小可调节。被线程共享，存放对象实例。

    1.8之前：新生代（eden生成区、s0幸存区FromSpace、s1幸存区ToSpace：8-1-1）、老年代、永久代
    1.8及之后：新生代（eden生成区、s0幸存区FromSpace、s1幸存区ToSpace：8-1-1）、老年代、Meta Space（元空间）
    元空间与永久带类似，都是方法区的实现，不过元空间不在JVM中，而是使用本地内存。

    为什么新生代的内存比例是8:1:1？
    1、对象的生命周期不一样，所以要分代
    2、新生代的对象，大部分理解为朝生兮死会被回收掉，所以只通过s1存储，就足够。利用率能到90%。
    3、分配担保概念，就是s1如果u不够用了，怎么办？可以放到老年代中。

    Minor GC，回收的是eden区；Major GC回收的是老年代；full GC回收整个堆；

堆、栈和方法区的调用关系：栈-》堆-》方法区










