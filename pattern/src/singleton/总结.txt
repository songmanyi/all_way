单例模式，大体分为四类：饿汉式、懒汉式、注册式单例和ThreadLocal单例。

1、资源浪费
2、线程安全问题
3、延迟加载的问题
4、反射破坏
5、序列化破坏

其中饿汉式，由于不管用不用都会加载，所以在单例模式比较多的清空下，比较浪费资源。
建议采用懒汉式的单例模式。


所以懒汉式单例模式，又分为了：
1、简单的懒汉式单例：
    存在线程安全问题
2、加锁的懒汉式单例：
    解决了线程安全问题，但是因为加锁，所以有延迟
3、Double-Check的懒汉式单例：
    解决了线程安全和延迟的问题，但需要特殊处理私有构造器，才能防反射破坏。
4、内部类的单例：
    外部类加载时，并不需要立即加载内部类，故而不浪费资源。
    不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。

注册式单例模式，分为枚举登记和容器缓存
5、枚举单例模式（推荐）：利用枚举的特性（jvm中只存在单实例+不能被反射+编译后为饿汉式保证唯一）
6、容器缓存：容器式写法适用于创建实例非常多的情况，便于管理。但是，是非线程安全的。

ThreadLocal式单例模式：
不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，天生的线程安全。
ThreadLocal将所有的对象全部放在 ThreadLocalMap 中，为每个线程都提供一个对象，实际上是以空间换时间来实现线程间隔离的。